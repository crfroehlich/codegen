//------------------------------------------------------------------------------
// <auto-generated>
//    This code is auto-generated by a T4 template. This class can be only customized modifying the corresponding partial class.
//    All other changes to this file will cause incorrect behavior and will be lost when
//    the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using AutoMapper;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Dynamic;
using System.Linq.Expressions;
using System.Net;
using System.Runtime.Serialization;

using Services.Core;
using Services.Db;
using Services.Dto;
using Services.Dto.internals;
using Services.Enums;
using Services.Models;

using ServiceStack;

using Typed.Notifications;
using Typed.Settings;

using Xtensive.Orm;
using Xtensive.Orm.Model;

using Attribute = Services.Dto.Attribute;
using ValueType = Services.Dto.ValueType;

namespace Services.Schema
{
    [TableMapping(DocConstantModelName.DATACLASS)]
    public partial class DocEntityDataClass : DocEntityBase
    {
        private const string DATACLASS_CACHE = "DataClassCache";
        public const string TABLE_NAME = DocConstantModelName.DATACLASS;
        
        #region Constructor
        public DocEntityDataClass(Session session) : base(session) {}

        public DocEntityDataClass() : base(new DocDbSession(Xtensive.Orm.Session.Current)) {}
        #endregion Constructor

        #region VisibleFields

        protected override List<string> _visibleFields
        {
            get
            {
                if(null == __vf)
                {
                    __vf = DocWebSession.GetTypeVisibleFields(new DataClass());
                }
                return __vf;
            }
        }

        #endregion VisibleFields

        #region Static Members
        public static DocEntityDataClass GetDataClass(Reference reference)
        {
            return (true == (reference?.Id > 0)) ? GetDataClass(reference.Id) : null;
        }

        public static DocEntityDataClass GetDataClass(int? primaryKey)
        {
            var query = DocQuery.ActiveQuery;
            if(null == primaryKey) return null;
            var ret = DocEntityThreadCache<DocEntityDataClass>.GetFromCache(primaryKey, DATACLASS_CACHE);
            if(null == ret)
            {
                ret = query.SelectAll<DocEntityDataClass>().Where(e => e.Id == primaryKey.Value).FirstOrDefault();
                if(null != ret) 
                {
                    DocEntityThreadCache<DocEntityDataClass>.UpdateCache(ret.Id, ret, DATACLASS_CACHE);
                    DocEntityThreadCache<DocEntityDataClass>.UpdateCache(ret.Hash, ret, DATACLASS_CACHE);
                }
            }
            return ret;
        }

        public static DocEntityDataClass GetDataClass(Guid hash)
        {
            var query = DocQuery.ActiveQuery;
            var ret = DocEntityThreadCache<DocEntityDataClass>.GetFromCache(hash, DATACLASS_CACHE);
            
            if(null == ret)
            {
                ret = query.SelectAll<DocEntityDataClass>().Where(e => e.Hash == hash).FirstOrDefault();
                if(null != ret) 
                {
                    DocEntityThreadCache<DocEntityDataClass>.UpdateCache(ret.Id, ret, DATACLASS_CACHE);
                    DocEntityThreadCache<DocEntityDataClass>.UpdateCache(ret.Hash, ret, DATACLASS_CACHE);
                }
            }
            return ret;
        }
        #endregion Static Members

        #region Properties
        [Field(DefaultValue = true)]
        [FieldMapping(nameof(AllowDelete))]
        public bool AllowDelete { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(AllVisibleFieldsByDefault))]
        public bool AllVisibleFieldsByDefault { get; set; }


        [Field(Nullable = false)]
        [FieldMapping(nameof(ClassId))]
        public int ClassId { get; set; }


        [Field()]
        [FieldMapping(nameof(CustomCollections))]
        public DocEntitySet<DocEntityDataProperty> CustomCollections { get; private set; }


        public int? CustomCollectionsCount { get { return CustomCollections.Count(); } private set { var noid = value; } }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(DELETE))]
        public bool DELETE { get; set; }


        [Field()]
        [FieldMapping(nameof(Description))]
        public string Description { get; set; }


        [Field()]
        [FieldMapping(nameof(DontFlattenProperties))]
        public DocEntitySet<DocEntityDataProperty> DontFlattenProperties { get; private set; }


        public int? DontFlattenPropertiesCount { get { return DontFlattenProperties.Count(); } private set { var noid = value; } }


        [Field()]
        [FieldMapping(nameof(DtoSuffix))]
        public string DtoSuffix { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(FlattenReferences))]
        public bool FlattenReferences { get; set; }


        [Field(DefaultValue = true)]
        [FieldMapping(nameof(GET))]
        public bool GET { get; set; }


        [Field()]
        [FieldMapping(nameof(IgnoreProps))]
        public DocEntitySet<DocEntityDataProperty> IgnoreProps { get; private set; }


        public int? IgnorePropsCount { get { return IgnoreProps.Count(); } private set { var noid = value; } }


        [Field(DefaultValue = true)]
        [FieldMapping(nameof(IsCached))]
        public bool IsCached { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(IsInsertOnly))]
        public bool IsInsertOnly { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(IsReadOnly))]
        public bool IsReadOnly { get; set; }


        [Field()]
        [FieldMapping(nameof(JsonIgnore))]
        public DocEntitySet<DocEntityDataProperty> JsonIgnore { get; private set; }


        public int? JsonIgnoreCount { get { return JsonIgnore.Count(); } private set { var noid = value; } }


        [Field(Nullable = false)]
        [FieldMapping(nameof(Name))]
        public string Name { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(PATCH))]
        public bool PATCH { get; set; }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(POST))]
        public bool POST { get; set; }


        [Field()]
        [FieldMapping(nameof(Properties))]
        [Association(PairTo = nameof(DocEntityDataProperty.Class), OnOwnerRemove = OnRemoveAction.Cascade, OnTargetRemove = OnRemoveAction.Clear)]
        public DocEntitySet<DocEntityDataProperty> Properties { get; private set; }


        public int? PropertiesCount { get { return Properties.Count(); } private set { var noid = value; } }


        [Field(DefaultValue = false)]
        [FieldMapping(nameof(PUT))]
        public bool PUT { get; set; }


        [Field()]
        [FieldMapping(nameof(Tabs))]
        [Association(PairTo = nameof(DocEntityDataTab.Class), OnOwnerRemove = OnRemoveAction.Cascade, OnTargetRemove = OnRemoveAction.Clear)]
        public DocEntitySet<DocEntityDataTab> Tabs { get; private set; }


        public int? TabsCount { get { return Tabs.Count(); } private set { var noid = value; } }



        [Field(LazyLoad = false, Length = Int32.MaxValue)]
        public override string Gestalt { get; set; }

        [Field(DefaultValue = 0), Version(VersionMode.Manual)]
        public override int VersionNo { get; set; }

        [Field]
        public override DateTime? Created { get; set; }

        [Field]
        public override DateTime? Updated { get; set; }

        [Field(DefaultValue = false)]
        [FieldMapping(nameof(Locked))]
        public override bool Locked { get; set; }

        [Field(DefaultValue = false)]
        [FieldMapping(nameof(Archived))]
        public override bool Archived { get; set; }

        #endregion Properties

        #region Overrides of DocEntity

        public override DocConstantModelName TableName => TABLE_NAME;

        public const string CACHE_KEY_PREFIX = "FindDataClasss";

        #endregion Overrides of DocEntity

        #region Entity overrides
        /// <summary>
        ///    Called when entity is about to be removed.
        /// </summary>
        protected override void OnRemoving()
        {
            try
            {
                Properties.Clear(); //foreach thing in Properties en.Remove();
            }
            catch(Exception ex)
            {
                throw new DocException("Failed to delete DataClass in Properties delete", ex);
            }
            try
            {
                Tabs.Clear(); //foreach thing in Tabs en.Remove();
            }
            catch(Exception ex)
            {
                throw new DocException("Failed to delete DataClass in Tabs delete", ex);
            }
            base.OnRemoving();
        }

        /// <summary>
        ///    Called when entity should be validated. Override this method to perform custom object validation.
        /// </summary>
        protected override void OnValidate()
        {
            if (false == ValidationMessage.IsValid)
            {
                throw new HttpError(HttpStatusCode.Conflict, $"DataClass requires: {ValidationMessage.Message}.");
            }

            base.OnValidate();

            FlushCache();

            _validated = true;


        }

        public override IDocEntity SaveChanges(DocConstantPermission permission = null)
        {
            Description = Description?.TrimAndPruneSpaces();
            DtoSuffix = DtoSuffix?.TrimAndPruneSpaces();
            Name = Name?.TrimAndPruneSpaces();
            return base.SaveChanges(permission);
        }

        public override void FlushCache()
        {
            base.FlushCache();
            DocCacheClient.RemoveById(Id);
        }
        #endregion Entity overrides

        #region Validation
        public DocValidationMessage ValidationMessage
        {
            get
            {
                var isValid = true;
                var message = string.Empty;

                if(DocTools.IsNullOrEmpty(ClassId))
                {
                    isValid = false;
                    message += " ClassId is a required property.";
                }
                if(DocTools.IsNullOrEmpty(Name))
                {
                    isValid = false;
                    message += " Name is a required property.";
                }

                var ret = new DocValidationMessage(message, isValid);
                return ret;
            }
        }
        #endregion Validation

        #region Converters

        public DataClass ToDto() => Mapper.Map<DocEntityDataClass, DataClass>(this);

        public override IDto ToIDto() => ToDto();
        #endregion Converters
    }

    public static partial class UniqueConstraintFilter
    {
        public static Expression<Func<DocEntityDataClass, bool>> DataClassIgnoreArchived() => d => d.Archived == false;
    }

    public partial class DataClassMapper : DocMapperBase
    {
        protected IMappingExpression<DocEntityDataClass,DataClass> _EntityToDto;
        protected IMappingExpression<DataClass,DocEntityDataClass> _DtoToEntity;

        public DataClassMapper()
        {
            CreateMap<DocEntitySet<DocEntityDataClass>,List<Reference>>()
                .ConvertUsing(s => s.ToReferences());
            CreateMap<DocEntityDataClass,Reference>()
                .ConstructUsing(s => null == s || !(s.Id > 0) ? null : s.ToReference());
            CreateMap<Reference,DocEntityDataClass>()
                .ForMember(dest => dest.Id, opt => opt.Condition(src => null != src && src.Id > 0))
                .ConstructUsing(c => DocEntityDataClass.GetDataClass(c));
            _EntityToDto = CreateMap<DocEntityDataClass,DataClass>()
                .ForMember(dest => dest.Created, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, "Created")))
                .ForMember(dest => dest.Updated, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, "Updated")))
                .ForMember(dest => dest.AllowDelete, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.AllowDelete))))
                .ForMember(dest => dest.AllVisibleFieldsByDefault, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.AllVisibleFieldsByDefault))))
                .ForMember(dest => dest.ClassId, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.ClassId))))
                .ForMember(dest => dest.CustomCollections, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.CustomCollections))))
                .ForMember(dest => dest.CustomCollectionsCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.CustomCollectionsCount))))
                .ForMember(dest => dest.DELETE, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.DELETE))))
                .ForMember(dest => dest.Description, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.Description))))
                .ForMember(dest => dest.DontFlattenProperties, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.DontFlattenProperties))))
                .ForMember(dest => dest.DontFlattenPropertiesCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.DontFlattenPropertiesCount))))
                .ForMember(dest => dest.DtoSuffix, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.DtoSuffix))))
                .ForMember(dest => dest.FlattenReferences, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.FlattenReferences))))
                .ForMember(dest => dest.GET, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.GET))))
                .ForMember(dest => dest.IgnoreProps, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.IgnoreProps))))
                .ForMember(dest => dest.IgnorePropsCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.IgnorePropsCount))))
                .ForMember(dest => dest.IsCached, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.IsCached))))
                .ForMember(dest => dest.IsInsertOnly, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.IsInsertOnly))))
                .ForMember(dest => dest.IsReadOnly, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.IsReadOnly))))
                .ForMember(dest => dest.JsonIgnore, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.JsonIgnore))))
                .ForMember(dest => dest.JsonIgnoreCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.JsonIgnoreCount))))
                .ForMember(dest => dest.Name, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.Name))))
                .ForMember(dest => dest.PATCH, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.PATCH))))
                .ForMember(dest => dest.POST, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.POST))))
                .ForMember(dest => dest.Properties, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.Properties))))
                .ForMember(dest => dest.PropertiesCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.PropertiesCount))))
                .ForMember(dest => dest.PUT, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.PUT))))
                .ForMember(dest => dest.Tabs, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.Tabs))))
                .ForMember(dest => dest.TabsCount, opt => opt.PreCondition(c => DocMapperConfig.ShouldBeMapped<DataClass>(c, nameof(DocEntityDataClass.TabsCount))))
                .MaxDepth(2);
            _DtoToEntity = CreateMap<DataClass,DocEntityDataClass>()
                .MaxDepth(2);
            ApplyCustomMaps();
        }
    }
}
